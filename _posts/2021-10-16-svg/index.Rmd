---
title: Interactive SVG with D3.js (draft)
description: |
  Part 1: add interactivity to IWMI's printable WA+ sheets.
author:
  - name: BACOU, Melanie
    email: mel@mbacou.com
    url: https://linkedin/in/mbacou
date: "`r Sys.Date()`"
date_prefix: 2021-10-01
categories:
  - draft
  - imwi
  - hydrology
output:
  distill::distill_article:
    toc: true
    dev: svglite
    code_folding: true
    self_contained: false
---

```{r setup}

library(knitr)
library(jsonlite)
library(ggplot2)
library(scales)
library(stringr)
library(data.table)

pal <- fread("
  color, name
  #004a72, blue
  #337ab7, light-blue
  #d9edf7, aqua
  #8a4f7d, purple
  #b185a7, fuschia
  #ff8811, orange
  #f4d06f, yellow
  #4da167, green
  #53dd6c, lime
  #dc493a, red
  #6b4b3e, maroon
  #96705b, olive")
pal <- pal$color
options(ggplot2.discrete.color=pal)

```


This notebook is to explore multiple visualization schemes:

1. **Interactive SVG**: add user interactivity to existing SVG sheets (or simplified) designs using low-level [D3.js](https://d3js.org/) library
2. **Graphviz**: redesign the WA+ sheets using [Graphviz](https://graphviz.org/) and provide interactivity with [DiagrammeR](https://rich-iannone.github.io/DiagrammeR/)
3. **Highcharts**: reshape WA+ model output to create more standard treemaps / sankey diagrams etc. using [Highcharts.js](https://www.highcharts.com/) charting library
4. **Leaflet**: create a 3D map of basin landscape with SVG annotation layers (arrows, etc.) using [leaflet.js](https://leafletjs.com/)

The **D3.js** approach is the more flexible but also the more tedious to implement. Other approaches will be developed in separate notebooks.


# Data Preparation

To validate the different approaches we use sample output datasets provided by **Naga Valpuri** for Mali (Niger river basin) and Kenya (Mara basin). All hydrological models are written in Python and published to GitHub (e.g. [Mali notebooks](https://github.com/wateraccounting/WAPORWA)).

```{r}

data <- list(
  ken = "~/Projects/2021-iwmi/data/ken/hydroloop_results/csv",
  mli = "~/Projects/2021-iwmi/data/mli/csv_km3"
) %>%
  lapply(list.files, pattern="*.csv", recursive=TRUE, full.names=TRUE) %>%
  lapply(data.table) %>%
  rbindlist(idcol="iso3", use.names=TRUE, fill=TRUE) %>%
  setnames("V1", "path")

data[, 
  file := basename(path)
][, `:=`(
  year = str_extract(file, "_[0-9]{4}") %>% str_sub(2,5) %>% as.integer(),
  month = str_extract(file, "[0-9]{4}_[0-9]{1,2}") %>% str_sub(6,7) %>% as.integer(),
  sheet = str_extract(tolower(file), "sheet[0-9]{1}") 
)] %>% setorder(iso3, year, month, na.last=TRUE)

data[iso3=="ken", .(file, sheet, year, month)][c(1:5, (.N-4):.N)] %>% 
  kable(caption="Kenya - List of output files (top and last 5)")
data[iso3=="mli", .(file, sheet, year, month)] %>% 
  kable(caption="Mali - List of output files")

```

In particular we have yearly model steps for Mali and monthly steps for Kenya that are further aggregated to yearly time spans (by variable), as well as monthly time-series. In Mali only **Sheet 1** was produced (Resource Base).

Let's load a sample output for Kenya for the year 2017.

```{r}

f <- "sheet1_2017.csv"
ken <- data[iso3=="ken" & file==f][1, fread(path)]
ken %>% 
  kable(caption=f)

```

This file lists `r nrow(ken)` output variables grouped into `CLASS` and `SUBCLASS`. Units are in **km³/year**. That categorical data can be represented in a Sankey diagram but not very useful as-is (see [next](#sankey) section).

```{r}

library(ggalluvial)
  
ggplot(ken, aes(axis1=CLASS, axis2=SUBCLASS, axis3=VARIABLE, y=VALUE)) +
  geom_alluvium(aes(fill=CLASS), width=1/4, alpha=.7, color="white") +
  geom_stratum(width=1/4) +
  geom_text(stat="stratum", aes(label=after_stat(stratum)), angle=90, size=2.2) +
  scale_x_discrete(limits=c("class", "subclass", "variable")) +
  labs(y=NULL, fill=NULL) +
  scale_fill_manual(values=pal) +
  theme(
    panel.grid=element_blank(),
    legend.position="top",
    axis.text=element_text(face="bold"))

```

And monthly time-series of Incremental ET by land-use classes:

```{r}

f <- "sheet1_basin_etincr_monthly.csv"
ken.ts <- data[iso3=="ken" & file==f][1, fread(path)]
ken.ts[c(1:5, (.N-4):.N)] %>% 
  kable(caption=f)

```

We'll gather all the **yearly** budgets for now into a long table, and plot the trends.

```{r, fig.asp=.7}

f <- data[sheet=="sheet1" & is.na(month) & !is.na(year)]

data <- lapply(1:nrow(f), function(x) 
  fread(f[x, path])[, `:=`(
    iso3 = f[x, iso3],
    sheet = f[x, sheet],
    year = f[x, year]
  )]) %>% rbindlist()

ggplot(data[VALUE>0 & SUBCLASS %like% "ET"], 
  aes(year, VALUE, color=paste(SUBCLASS, VARIABLE, sep=" "))) +
  geom_line(size=1) +
  facet_wrap(~toupper(iso3), scales="free") +
  labs(x=NULL, y="kg/m³", color=NULL) +
  scale_color_manual(values=pal) +
  guides(color=guide_legend(ncol=3)) +
  theme(
    legend.position="top")

```

We make a yearly dataset available in the client as a JSON array named `data`. We also pass a default color palette `pal` for convenience.

```{r, results="asis"}

cat(
  sprintf("
  <script> 
  var data = %s;
  var pal = %s;
  </script>", toJSON(data[iso3=="ken" & year==2017]), toJSON(pal)))

```


# Interactive SVG

We work off the existing SVG designs, using `D3.js` constructs to add data binding and interactions. An important drawback of this approach is that each SVG element (rectangle, arrow, text, etc.) is tied to a data variable, so any change in the underlying data schema (esp. renaming of output variables) would require to manually edit the corresponding SVG sheet (using a text or vector graphic editor).

There are multiple SVG template sheets provided in the Kenya code repository (under `./scripts/WAsheets/template/svg`). They are shown below.

```{r, out.width="33%", fig.width=3, fig.show="hold", preview=TRUE}

svg <- "../../www/svg" %>%
  list.files(pattern="*.svg", full.names=TRUE)
include_graphics(svg[-c(2:4, 7, 9)])

```

These sheets incorporate a quantity of domain-specific knowledge, they are used to both teach and communicate about the WA+ approach and simulation results. They are produced in the final step of the analysis, typically after the water accounts have been aggregated to a seasonal or yearly time span. The process is somewhat (but not entirely) automated, e.g. the analyst can decide to add or hide elements.

Note that the original templates were created in Inkscape with **SVG 1.1** specifications. They are professional printable designs and not optimized for rendering in a browser, so we start by testing whether we can interact and modify these designs using D3. We focus on the Resource Base sheet first. 

> <u>Note</u>: Inkscape provides a templating system that allows merging a SVG file (with template fields declared in the form `%VAR_name%` with a CSV data file to batch generate PNG or PDF documents. That system is not limited to merging text labels, colors and sizes can also be read in from an external CSV source[^ink].

[^ink]: Refer to [inkscape_merge](https://github.com/borgand/inkscape_merge) tool.


Below we load the sheet and proceed to map each box height/width and label to an output variable. We also create a dummy SVG barchart widget to make sure that data is read and rendered in the browser as expected.

Provide D3 as an external dependency in this notebook:

```{r, results="asis", code_folding=FALSE}

# Import D3
htmltools::tags$script(src="https://d3js.org/d3.v6.min.js")
```

First we create a dummy SVG widget using the sample Kenya data for 2017 (to make sure libraries are loaded).

::: {#d3ex1 .l-body}
:::

:::{.l-gutter}
<button onclick="fun_barchart();">Dummy Widget</button>
:::

```{js, code_folding=F}

// Keep only non-null variables
var dd = data.filter((d) => (d.VALUE !== 0));

function fun_barchart(data=dd, target="#d3ex1") {

  d3.select(target).selectAll("svg").remove();

  var width = $(target).width() - 10;
  var box = 0.6 * width/18;
  var height = box * 21;
  
  var svg = d3.select(target)
    .append("svg")
    .attr("viewBox", [0, 0, width, height])
    .append("g")
      .attr("transform", "translate(10, 10)");  
    
  // Add X axis 
  var x = d3.scaleLinear()
    .domain([0, 14])
    .range([0, width]);
  
  svg
    .selectAll("mybar")
    .data(data)
    .enter()
    .append("rect")
    .attr("x", d => x(Math.min(0, d.VALUE)) )
    .attr("y", (_, i) => (i * (box+5)+5) )
    .attr("width", d => 0 )
    .attr("height", box)
    .attr("fill", pal[1])
    .on("mouseover", handleMouseOver)
    .on("mouseout", handleMouseOut);
    
svg.selectAll("mybar")
    .data(data)
    .enter()
    .append("text")
    .attr("x", d => x(0)+10)
    .attr("y", (_, i) => (i * (box+5) + box)  )
    .style("font-size", box*0.6 + "px")
    .attr("text-anchor", "start")
    .text(d => (d.VALUE.toFixed(2) + " km³/year"));
    
  svg
    .append("g")
    .selectAll("text")
    .data(data)
    .enter()
    .append("text")
    .attr("x", width-20)
    .attr("y", (_, i) => (i * (box+5) + box) )
    .style("font-size", box*.6+"px")
    .attr("text-anchor", "end")
    .text(d => (d.SUBCLASS + " - " + d.VARIABLE));
    
  // Animation
  svg.selectAll("rect")
    .transition()
    .duration(800)
    .attr("width", d => x(Math.abs(d.VALUE)))
    .delay((d,i) => i*100);
};

// Test interactions
function handleMouseOver(d, i) {
   d3.select(this).style("fill", pal[2]);
};

function handleMouseOut(d, i, fill=pal[1]) {
  d3.select(this).style("fill", fill);
};

```

Then we load the original SVG design and progressively add data bindings.

::: {#d3ex2 .l-body}
:::

:::{.l-gutter}
<button onclick="fun_color();">Change Text Color</button>
<button onclick="fun_fill();">Change Fill Color</button>
<button onclick="fun_group();">Show Groups</button>
<button onclick="fun_reset();">Reset Widget</button>
:::

```{js, code_folding=FALSE}

var hw = $("#d3ex2").width();
var div = d3.select("#d3ex2");
var svg = div
  .append("svg")
  .attr("viewBox", [0, 0, hw, hw*0.8])
  .insert("svg:g")
  .attr("class", "d3ex2");  

function fun_reset(target="d3ex2", src="../../www/svg/sheet_1_old.svg") {
  d3.select("." + target).selectAll("svg").remove();

  // Append external design
  d3.xml(src)
    .then(d => {
    d3.select("." + target).node().append(d.documentElement);
    });
};

fun_reset();

svg
  .selectAll("path")
  .on("mouseover", handleMouseOver);

```

Now that we have the SVG DOM loaded, we can do silly things, like change the text color or highlight some elements. We can also list all text elements with default value "NaN", so that we can start mapping labels to data values.

```{js, code_folding=FALSE}

d3.selection.prototype.move = function(x, y) {
  this
    .transition()
    .duration(800)
    .attr("transform", "translate(" + x + "," + y + ")");
  return this;
};

function fun_color(el="d3ex2") {
  d3.select("." + el)
  .select("svg")
  .selectAll("text")
   .style("fill", "white");
 };
 
function fun_fill(el="d3ex2") {
  d3.select("." + el)
  .selectAll("path")
    .style("fill", pal[0]);
 };
 
function fun_group(el="d3ex2") {
  d3.select("." + el)
  .selectAll("g")
  .selectAll("path")
    .style("stroke", pal[9])
    .raise()
    .move(-20, -20);
 };

```

At this point, we need to manually modify (simplify) the original SVG design to clean up paths and to make it easier to select and manipulate (drill through) logical layers and groups of elements. We can create a useful hierarchy in Inkscape and then re-import the modified design here.

::: {#d3ex3 .l-body}
:::

:::{.l-gutter}
<button onclick="fun_group('d3ex3');">Show Groups</button>
<button onclick="fun_reset('d3ex3', '../../www/svg/sheet_1.svg');">Reset Design</button>
:::

```{js, code_folding=FALSE}

var div = d3.select("#d3ex3");
var svg = div
  .append("svg")
  .attr("viewBox", [0, 0, hw, hw*0.8])
  .insert("svg:g")
  .attr("class", "d3ex3");

fun_reset("d3ex3", "../../www/svg/sheet_1.svg");

d3.select(".d3ex3")
  .selectAll("rect")
  .on("mouseover", handleMouseOver);

```

Next step is to map text labels to data variables.


# Graphviz

[placeholder]

# References

