---
title: Interactive SVG with D3.js (draft)
description: |
  Part 1: add interactivity to IWMI's printable WA+ sheets.
author:
  - name: BACOU, Melanie
    email: mel@mbacou.com
    url: https://linkedin/in/mbacou
date: "`r Sys.Date()`"
date_prefix: 2021-10-01
categories:
  - draft
  - imwi
  - hydrology
output:
  distill::distill_article:
    toc: true
    dev: svglite
    code_folding: true
    self_contained: false
---

```{r setup}

library(knitr)
library(jsonlite)
library(scales)
library(stringr)
library(data.table)

opts_chunk$set(res=220, pointsize=8)
pal <- readRDS("../../_assets/palette.rds")

```


This notebook is to explore multiple visualization schemes:

1. **Interactive SVG**: add user interactivity to existing SVG sheets (or simplified) designs using low-level [D3.js](https://d3js.org/) JavaScript library
2. **Graphviz**: redesign the WA+ sheets using [Graphviz](https://graphviz.org/) and provide interactivity with [DiagrammeR](https://rich-iannone.github.io/DiagrammeR/)
2. **Highcharts**: reshape WA+ model output to create more standard treemaps using [Highcharts.js](https://www.highcharts.com/) charting library
3. **Highcharts**: reshape WA+ model output to create custom steam graphs and/or network graphs
4. **Leaflet**: create a 3D map of basin landscape with SVG annotation layers (arrows, etc.) using [leaflet.js](https://leafletjs.com/)

The **D3.js** approach is the more flexible but also the more difficult to implement (success is uncertain). Other approaches will be developed in separate notebooks.


# Data Preparation

To validate the different approaches we use sample output datasets provided by **Naga Valpuri** for Mali (Niger river basin) and Kenya (Mara basin). All hydrological models are written in Python and published to GitHub (e.g. [Mali notebooks](https://github.com/wateraccounting/WAPORWA)).

```{r}

data <- list(
  ken = "~/Projects/2021-iwmi/data/ken/hydroloop_results/csv",
  mli = "~/Projects/2021-iwmi/data/mli/csv_km3"
) %>%
  lapply(list.files, pattern="*.csv", recursive=TRUE, full.names=TRUE) %>%
  lapply(data.table) %>%
  rbindlist(idcol="iso3", use.names=TRUE, fill=TRUE) %>%
  setnames("V1", "path")

data[, 
  file := basename(path)
][, `:=`(
  year = str_extract(file, "_[0-9]{4}") %>% str_sub(2,5) %>% as.integer(),
  month = str_extract(file, "[0-9]{4}_[0-9]{1,2}") %>% str_sub(6,7) %>% as.integer()
)] %>% setorder(iso3, year, month, na.last=TRUE)

data[iso3=="ken", .(file, year, month)][c(1:5, (.N-4):.N)] %>% 
  kable(caption="Kenya - List of output files (top and last 5)")
data[iso3=="mli", .(file, year, month)] %>% 
  kable(caption="Mali - List of output files")

```

In particular we have yearly (2 seasons) model steps for Mali and monthly steps for Kenya that are further aggregated to seasonal and yearly time spans (by variable), as well as monthly time-series. In Mali only **Sheet 1** was produced (Resource Base).

Let's load a sample output for Kenya for the year 2017.

```{r}

f <- "sheet1_2017.csv"
ken <- data[iso3=="ken" & file==f][1, fread(path)]
ken %>% 
  kable(caption=f)

```

This file lists `r nrow(ken)` output variables grouped into `CLASS` and `SUBCLASS`. Units are in **km³/year**.

And monthly time-series of Incremental ET by land-use classes:

```{r}

f <- "sheet1_basin_etincr_monthly.csv"
ken.ts <- data[iso3=="ken" & file==f][1, fread(path)]
ken.ts[c(1:5, (.N-4):.N)] %>% 
  kable(caption=f)

```

We make the yearly dataset available in the client as a JSON array named `data`. We also pass a default color palette `pal` for convenience.

```{r, results="asis"}

cat(
  sprintf("
  <script> 
  var data = %s;
  var pal = %s;
  </script>", toJSON(ken), toJSON(pal)))

```


# Interactive SVG

We work off the existing SVG designs, using `D3.js` API to add data binding and interactions. An important drawback of this approach is that each SVG element (rectangle, arrow, text, etc.) is tied to a data variable, so any change in the underlying data schema (esp. renaming of output variables) would require to manually edit the corresponding SVG sheet (using a text or vector graphic editor).

There are multiple SVG template sheets provided in the Kenya code repository (under `./scripts/WAsheets/template/svg`). They are shown below.

```{r, out.width="33%", fig.width=3, fig.show="hold"}

svg <- "../../www/svg" %>%
  list.files(pattern="*.svg", full.names=TRUE)
include_graphics(svg[-c(1:2, 6, 8)])

```

These sheets incorporate a quantity of domain-specific knowledge, they are used to both teach and communicate about the WA+ approach and simulation results. They are produced in the final step of the analysis (using vector graphic templates), typically after the water accounts have been aggregated to a seasonal or yearly time span. The process is somewhat (but not entirely) automated, e.g. the analyst can decide to add or hide elements.

Note that the original templates were created in Inkscape with **SVG 1.1** specifications. They are professional printable designs and not optimized for rendering in a browser, so we start by testing whether we can interact and modify these designs using D3. We focus on the Resource Base sheet first. 

> <u>Note</u>: Inkscape provides a templating system that allows merging a SVG file (with template fields declared in the form `%VAR_name%` with a CSV data file to batch generate PNG or PDF documents. That system is not limited to merging text labels, colors and sizes can also be read in from an external CSV source[^ink].

[^ink]: Refer to [inkscape_merge](https://github.com/borgand/inkscape_merge) tool.


Below we load the sheet and proceed to map each box height/width and label to an output variable. We also create a dummy SVG barchart widget to make sure that data is read and rendered in the browser as expected.

Provide D3 as an external dependency in this notebook.

```{r, results="asis", code_folding=FALSE}

# Import D3
htmltools::tags$script(src="https://d3js.org/d3.v6.min.js")

```

First we create a dummy SVG widget using the sample Kenya data for 2017.

::: {#d3ex1 .l-body}
:::

```{js, code_folding=F}

// Keep only non-null variables
var dd = data.filter((d) => (d.VALUE !== 0));

const hw = $("#d3ex1").width();
const box = .6*hw/18;
const max_value = 13;

var svg = d3.select("#d3ex1")
  .append("svg")
  .attr("viewBox", [0, 0, hw, box*18]);

svg
  .selectAll("rect")
  .data(dd)
  .enter()
  .append("rect")
  .attr("x", d => Math.min(80, 80+((hw-80)*d.VALUE/max_value)) )
  .attr("y", (_, i) => (i * (box+5)+5) )
  .attr("width", d => (hw-80)*Math.abs(d.VALUE)/max_value )
  .attr("height", box)
  .attr("fill", d => pal[3])
  .on("mouseover", handleMouseOver)
  .on("mouseout", handleMouseOut);

svg
  .append("g")
  .selectAll("text")
  .data(dd)
  .enter()
  .append("text")
  .attr("x", 90)
  .attr("y", (_, i) => (i * (box+5)+box) )
  .style("fill", "black")
  .style("font-size", ".8em")
  .attr("text-anchor", "start")
  .text((d) => (d.VALUE.toFixed(2) + " km³/year"));
  
svg
  .append("g")
  .selectAll("text")
  .data(dd)
  .enter()
  .append("text")
  .attr("x", hw-10)
  .attr("y", (_, i) => (i * (box+5)+box) )
  .style("fill", "black")
  .style("font-size", ".8em")
  .attr("text-anchor", "end")
  .text((d) => (d.SUBCLASS + " - " + d.VARIABLE));  

// Test interactions
function handleMouseOver(d, i) {
  d3.select(this)
  .style("fill", pal[4])
  .move(1, 0)
};

function handleMouseOut(d, i) {
  d3.select(this)
  .style("fill", pal[3])
  .move(-1, 0)
};

d3.selection.prototype.move = function(x, y) {
  this.attr("transform", "translate(" + x + "," + y + ")");
  return this;
};

```

Then we load the original SVG design and progressively add data bindings.

::: {#d3ex2 .l-body}
:::

:::{.l-gutter}
<button onclick="fun_color();">Change Text Color</button>
<button onclick="fun_fill();">Change Fill Color</button>
<button onclick="fun_move('path8792');">Translate</button>
<button onclick="fun_reset();">Reset Design</button>
:::

```{js, code_folding=FALSE}

var div = d3.select("#d3ex2");
var svg = div
  .append("svg")
  .attr("viewBox", [0, 0, hw, hw*0.8])
  .insert("svg:g")
  .attr("class", "d3ex2");  

function fun_reset(src="../../www/svg/sheet_1.svg") {
  svg.selectAll("svg").remove();

  // Append external design
  d3.xml(src)
    .then(d => {
    svg.node().append(d.documentElement);
    });
};

fun_reset();

```

Now that we have the SVG DOM loaded, we can do silly things, like change the text color or move (translate) some elements. We can also list all text elements with default value "NaN", so that we can start mapping labels to data values.

```{js, code_folding=FALSE}

function fun_color() {
  svg
   .selectAll("text")
   .style("fill", "red");
 };
 
function fun_fill() {
  svg
   .selectAll("path").style("fill", "red");
 };
 
function fun_move(id) {
  svg.select("#"+id) 
    .raise()
    .move(-20, -20);
 };  
 
var vars = svg.selectAll("text[text='NaN']").id();
div.append(p).html(vars);

```



# Graphviz

[placeholder]

# References

